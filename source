#include <iostream>

using namespace std;

#include <iostream>
#include <string>

using namespace std;

// Structure représentant un produit dans le stock
struct Produit {
    int id;              // Identifiant unique (clé de tri pour l'ABR) [cite: 89, 90]
    string nom;          // Nom du produit
    int quantite;        // Quantité en stock
    double prix;         // Prix unitaire
};

// Structure d'un nœud de l'Arbre Binaire de Recherche
struct Noeud {
    Produit elt;         // Données du produit
    Noeud *gauche;       // Pointeur vers le fils gauche (IDs plus petits)
    Noeud *droit;        // Pointeur vers le fils droit (IDs plus grands)

    // Constructeur pour simplifier la création d'un nouveau nœud
    Noeud(Produit p) {
        elt = p;
        gauche = nullptr;
        droit = nullptr;
    }
};

Noeud* inserer(Noeud* racine, Produit p) {
    // Si l'arbre (ou sous-arbre) est vide, on crée le nœud ici
    if (racine == nullptr) {
        return new Noeud(p);
    }

    // Sinon, on descend dans l'arbre selon l'ID
    if (p.id < racine->elt.id) {
        racine->gauche = inserer(racine->gauche, p);
    } else if (p.id > racine->elt.id) {
        racine->droit = inserer(racine->droit, p);
    }

    return racine;
}

void afficherInventaire(Noeud* racine) {
    if (racine != nullptr) {
        // 1. On va tout à gauche (les plus petits IDs)
        afficherInventaire(racine->gauche);

        // 2. On affiche le produit actuel
        cout << "ID: " << racine->elt.id
             << " | Nom: " << racine->elt.nom
             << " | Stock: " << racine->elt.quantite
             << " | Prix: " << racine->elt.prix << " FCFA" << endl;

        // 3. On va à droite (les IDs plus grands)
        afficherInventaire(racine->droit);
    }
}

Noeud* rechercher(Noeud* racine, int idRecherche) {
    // Si l'arbre est vide ou si on a trouvé le produit
    if (racine == nullptr || racine->elt.id == idRecherche) {
        return racine;
    }

    // Si l'ID cherché est plus petit, on cherche à gauche
    if (idRecherche < racine->elt.id) {
        return rechercher(racine->gauche, idRecherche);
    }

    // Sinon, on cherche à droite
    return rechercher(racine->droit, idRecherche);
}

void mettreAJourStock(Noeud* racine, int id, int nouvelleQuantite) {
    Noeud* produitTrouve = rechercher(racine, id);
    if (produitTrouve != nullptr) {
        produitTrouve->elt.quantite = nouvelleQuantite; // Modification de la valeur elt
        cout << "Stock mis a jour pour: " << produitTrouve->elt.nom << endl;
    } else {
        cout << "Produit non trouve." << endl;
    }
}

void alerteRupture(Noeud* racine, int seuil) {
    if (racine == nullptr) return;

    // On vérifie le produit actuel
    if (racine->elt.quantite < seuil) {
        cout << "ALERTE: Le produit " << racine->elt.nom
             << " est presque épuisé (" << racine->elt.quantite << " restants)" << endl;
    }

    // On continue l'inspection dans les deux sous-arbres
    alerteRupture(racine->gauche, seuil);
    alerteRupture(racine->droit, seuil);
}

double calculerValeurTotale(Noeud* racine) {
    // Cas de base : si l'arbre est vide, la valeur est 0
    if (racine == nullptr) {
        return 0.0;
    }

    // Calcul pour le nœud actuel
    double valeurActuelle = racine->elt.quantite * racine->elt.prix;

    // Appel récursif pour sommer tout l'arbre
    return valeurActuelle + calculerValeurTotale(racine->gauche) + calculerValeurTotale(racine->droit);
}

void menu() {
    cout << "\n==================================================" << endl;
    cout << "       BIENVENU DANS GESTION-STOCK BY DANIEL      " << endl;
    cout << "==================================================" << endl;
    cout << "  1. Ajouter un nouveau produit" << endl;
    cout << "  2. Afficher l'inventaire complet (Tri ABR)" << endl;
    cout << "  3. Mettre a jour la quantite d'un produit" << endl;
    cout << "  4. Verifier les alertes de rupture" << endl;
    cout << "  5. Calculer la valeur totale du stock" << endl;
    cout << "  0. Quitter l'application" << endl;
    cout << "==================================================" << endl;
    cout << "  Votre choix : ";
}

int main() {
    Noeud* monStock = nullptr; // Racine de l'arbre [cite: 89]
    int choix;

    do {
        menu();
        cin >> choix;

        switch (choix) {
            case 1: {
                Produit p;
                cout << "ID : "; cin >> p.id;
                cout << "Nom : "; cin >> p.nom;
                cout << "Quantite : "; cin >> p.quantite;
                cout << "Prix : "; cin >> p.prix;
                monStock = inserer(monStock, p); // Insertion ABR [cite: 92]
                cout << "\nProduit ajoute avec succes !" << endl;
                break;
            }
            case 2:
                cout << "\n--- INVENTAIRE COMPLET (PARCOURS INFIXE) ---" << endl;
                afficherInventaire(monStock); // Parcours infixe [cite: 94]
                break;
            case 3: {
                int id, qte;
                cout << "ID du produit a modifier : "; cin >> id;
                cout << "Nouvelle quantite : "; cin >> qte;
                mettreAJourStock(monStock, id, qte); // Recherche et MAJ [cite: 93]
                break;
            }
            case 4: {
                int seuil;
                cout << "Entrez le seuil d'alerte : "; cin >> seuil;
                cout << "\n--- PRODUITS EN RUPTURE ---" << endl;
                alerteRupture(monStock, seuil); // Parcours récursif [cite: 95]
                break;
            }
            case 5:
                cout << "\nValeur totale du stock : "
                     << calculerValeurTotale(monStock) << " FCFA" << endl; // Somme récursive [cite: 98]
                break;
            case 0:
                cout << "Fermeture de l'application. Au revoir !" << endl;
                break;
            default:
                cout << "Choix invalide, recommencez." << endl;
        }
    } while (choix != 0);

    return 0;
}
